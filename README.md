SegmentDetector
===============

Based on R-TREE
Описание дерева: каждая вершина(node) хранит либо список отрезков (content),
если она является листом дерева, либо список сыновей(children), если
листом не является. Когда мы добавляем отрезок, мы ищем лист в который
его будем добавлять (метод choose_leaf). Начинаем спускаться от корня дерева, 
каждый раз переходим в вершину, добавление отрезка в которую потребует 
минимального увеличения её границ (edges, границы вершины - прямоугольник
минимальной площади, который содержит все её подвершины, если она не лист,
или все её отрезки, если она лист). Когда пришли в лист, закидываем в него
отрезок. Если кол-во отрезков в вершине превысило максимальное (max_content_in_node),
то мы разделяем вершину на две, и подвешиваем обе к вершине, которая являлась
предком(parent) разделяемой (метод adjust_tree). Затем рекурсивно рассматриваем
ту вершину, к которой подвесили. Если в ней кол-во сыновей превысило максимальное,
то делим и её. Разделение - один из популярных для р-дерева алг. quadratic_split.
Суть quadratic_split - сначала берём опорные вершины(или отрезки, на то этот метод
у меня и шаблонный, мы не знаем, будем разделять лист или не лист). Опорные вершины
выбираем так: для любых 2-х вершин считаем мин. площадь прямоугольников, которые их
включают, пусть это будут S1 и S2. Затем считаем S - мин. площадь прямоугольника, который
включает обе эти вершины. Опорными вершинами будут те, у которых S - S1 - S2
(назовём это минимальным расширением) максимально, т.е. фактически самые 
дальние друг от друга вершины. Добавляем опорные вершины по одной в каждую 
вершину-результат деления. Затем ищем следующую для добавления вершину. 
Для каждой вершины считаем минимальное расширение для каждой из двух групп.
Назовём эти минимальные расширения d1 и d2. Следующей для добавления вершиной
будет вершина, у которой d1-d2 максимально. Добавим эту вершину в ту группу,
для которой минимальное расширение меньше( если они равны - добавим в ту, в
которой меньше вершин ). В итоге получим 2 новые вершины, по которым
будет раскинуты всё содержимое разделяемой вершины. Для них вызываем 
adjust_tree. Если разделили корень - создаём новый корень, сыновьями которого
будут вершины, которые получились после разделения( высота дерева соотв. увеличится ).
Алгоритм поска (find_segments) заключается в посещении всех вершин, границы
которых пересекаются с запросом. Если вершина - лист, ищем все отрезки, входящие
в запрос. Иначе переходим во всех детей, границы которых пересекаются с запросом. 
Оценка сложности: напрямую зависит от алгорима разделения. Худшие случаи для вставки
- O(n), для поиска O(m*logm(N)), где m - максимальное кол-во детей вершины.
Средняя вставка O(m*logm(N)), средний поиск O(logm(N)). На самом деле точно оценить
сложность весьма непросто, но на практике алготм на больших объёмах данных показывает
себя хорошо.
 
